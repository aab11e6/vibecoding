<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pink Heart 3D</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(ellipse at 50% 58%, rgba(255, 120, 220, 0.10), transparent 42%),
        radial-gradient(ellipse at 50% 82%, rgba(170, 120, 255, 0.12), transparent 38%),
        radial-gradient(ellipse at 50% 50%, rgba(255,255,255,0.03), transparent 65%);
    }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from "./vendor/three.module.min.js";

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(34, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0.25, 11.2);
    camera.lookAt(0, 0.7, 0);

    const root = new THREE.Group();
    scene.add(root);

    const clock = new THREE.Clock();

    function rand(a, b) { return a + Math.random() * (b - a); }
    function clamp(x, a, b) { return Math.min(b, Math.max(a, x)); }
    function smoothstep(a, b, x) {
      const t = clamp((x - a) / (b - a), 0, 1);
      return t * t * (3 - 2 * t);
    }

    function createSoftDotTexture() {
      const c = document.createElement("canvas");
      c.width = 128;
      c.height = 128;
      const g = c.getContext("2d");
      const grd = g.createRadialGradient(64, 64, 2, 64, 64, 60);
      grd.addColorStop(0.0, "rgba(255,255,255,1)");
      grd.addColorStop(0.10, "rgba(255,240,250,0.98)");
      grd.addColorStop(0.30, "rgba(255,190,236,0.85)");
      grd.addColorStop(0.52, "rgba(255,150,226,0.28)");
      grd.addColorStop(1.0, "rgba(255,120,220,0)");
      g.fillStyle = grd;
      g.fillRect(0, 0, 128, 128);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    const dotTex = createSoftDotTexture();

    function makePointMaterial(opacity, options = {}) {
      const additive = options.additive ?? true;
      return new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: additive ? THREE.AdditiveBlending : THREE.NormalBlending,
        vertexColors: true,
        uniforms: {
          uTex: { value: dotTex },
          uOpacity: { value: opacity },
          uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
        },
        vertexShader: `
          attribute float aSize;
          varying vec3 vColor;
          varying float vFade;
          uniform float uPixelRatio;
          void main() {
            vColor = color;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * mv;
            gl_PointSize = aSize * uPixelRatio / max(1.0, -mv.z * 0.18);
            vFade = clamp(1.0 - (-mv.z / 28.0), 0.15, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D uTex;
          uniform float uOpacity;
          varying vec3 vColor;
          varying float vFade;
          void main() {
            vec4 t = texture2D(uTex, gl_PointCoord);
            if (t.a < 0.07) discard;
            gl_FragColor = vec4(vColor * (0.72 + t.rgb * 0.85), t.a * uOpacity * vFade);
          }
        `
      });
    }

    const PINK = new THREE.Color(0xffd9e7);
    const PINK2 = new THREE.Color(0xffeaf2);
    const LAV = new THREE.Color(0xf3dfe9);
    const WHITEP = new THREE.Color(0xfff8fb);
    const tempColor = new THREE.Color();

    function setColor(arr, i, c) {
      arr[i] = c.r;
      arr[i + 1] = c.g;
      arr[i + 2] = c.b;
    }

    // ---------- Heart cloud (clear silhouette, with more depth) ----------
    const HEART_COUNT = 2600;
    const heartPos = new Float32Array(HEART_COUNT * 3);
    const heartCol = new Float32Array(HEART_COUNT * 3);
    const heartSize = new Float32Array(HEART_COUNT);
    const heartTarget = new Array(HEART_COUNT);
    const heartSeed = new Float32Array(HEART_COUNT);
    const heartSpawn = new Array(HEART_COUNT);

    function randomHeartPoint(fillBias = true) {
      // 2D heart fill / edge mix for a clear front silhouette.
      if (fillBias && Math.random() < 0.78) {
        const t = Math.random() * Math.PI * 2;
        const x = 16 * Math.pow(Math.sin(t), 3) / 16;
        const y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;
        return { x, y, edge: true };
      }
      for (let k = 0; k < 2000; k++) {
        const x = rand(-1.15, 1.15);
        const y = rand(-1.1, 1.15);
        const f = Math.pow(x * x + y * y - 1, 3) - x * x * Math.pow(y, 3);
        if (f <= 0) {
          return { x, y, edge: false };
        }
      }
      return { x: 0, y: 0, edge: false };
    }

    for (let i = 0; i < HEART_COUNT; i++) {
      const hp = randomHeartPoint(true);
      const thickness = hp.edge ? 0.18 : 0.42;
      const scale = hp.edge ? 1.92 : rand(1.62, 1.82);
      const tx = hp.x * scale * (hp.edge ? 1.0 : rand(0.92, 1.02));
      const ty = hp.y * scale * 0.95 + 2.15;
      const tz = rand(-thickness, thickness) * (hp.edge ? 0.95 : 1.15);
      heartTarget[i] = new THREE.Vector3(tx, ty, tz);

      heartSpawn[i] = new THREE.Vector3(
        rand(-0.55, 0.55),
        rand(-1.0, -0.25),
        rand(-0.35, 0.35)
      );

      heartSeed[i] = Math.random() * Math.PI * 2;
      heartSize[i] = hp.edge ? rand(9, 14) : rand(6, 10);

      tempColor.copy(Math.random() < 0.72 ? PINK : (Math.random() < 0.5 ? PINK2 : LAV));
      tempColor.offsetHSL(rand(-0.02, 0.02), rand(-0.03, 0.03), rand(-0.04, 0.06));
      setColor(heartCol, i * 3, tempColor);
    }

    const heartGeo = new THREE.BufferGeometry();
    heartGeo.setAttribute("position", new THREE.BufferAttribute(heartPos, 3));
    heartGeo.setAttribute("color", new THREE.BufferAttribute(heartCol, 3));
    heartGeo.setAttribute("aSize", new THREE.BufferAttribute(heartSize, 1));
    const heartMat = makePointMaterial(0.92, { additive: false });
    const heartPoints = new THREE.Points(heartGeo, heartMat);
    root.add(heartPoints);

    // ---------- Floor pool ----------
    const FLOOR_COUNT = 3200;
    const floorPos = new Float32Array(FLOOR_COUNT * 3);
    const floorCol = new Float32Array(FLOOR_COUNT * 3);
    const floorSize = new Float32Array(FLOOR_COUNT);
    const floorMeta = new Array(FLOOR_COUNT);

    for (let i = 0; i < FLOOR_COUNT; i++) {
      const ring = Math.random();
      const a = Math.random() * Math.PI * 2;
      const r = Math.pow(Math.random(), 0.78) * 4.0;
      floorMeta[i] = {
        a,
        r,
        y: rand(-2.85, -2.55),
        phi: Math.random() * Math.PI * 2,
        oval: rand(0.55, 0.78),
        ring
      };
      floorSize[i] = ring > 0.83 ? rand(12, 22) : rand(8, 16);
      tempColor.copy(Math.random() < 0.55 ? LAV : PINK);
      tempColor.offsetHSL(rand(-0.02, 0.02), rand(-0.02, 0.03), rand(-0.05, 0.03));
      setColor(floorCol, i * 3, tempColor);
    }

    const floorGeo = new THREE.BufferGeometry();
    floorGeo.setAttribute("position", new THREE.BufferAttribute(floorPos, 3));
    floorGeo.setAttribute("color", new THREE.BufferAttribute(floorCol, 3));
    floorGeo.setAttribute("aSize", new THREE.BufferAttribute(floorSize, 1));
    const floorMat = makePointMaterial(0.56, { additive: true });
    const floorPoints = new THREE.Points(floorGeo, floorMat);
    root.add(floorPoints);

    // ---------- Shedding particles (slowly falling from the heart) ----------
    const STREAM_COUNT = 1300;
    const streamPos = new Float32Array(STREAM_COUNT * 3);
    const streamCol = new Float32Array(STREAM_COUNT * 3);
    const streamSize = new Float32Array(STREAM_COUNT);
    const streamMeta = new Array(STREAM_COUNT);

    for (let i = 0; i < STREAM_COUNT; i++) {
      streamMeta[i] = {
        phase: Math.random(),
        dur: rand(4.8, 8.8),
        drift: rand(0.12, 0.65),
        seed: Math.random() * Math.PI * 2,
        x0: rand(-0.25, 0.25),
        z0: rand(-0.18, 0.18),
        x1: rand(-1.3, 1.3),
        z1: rand(-0.75, 0.75),
        arc: rand(0.05, 0.35),
        sourceIndex: (Math.random() * HEART_COUNT) | 0
      };
      streamSize[i] = rand(3, 7);
      tempColor.copy(Math.random() < 0.7 ? WHITEP : (Math.random() < 0.5 ? PINK2 : PINK));
      tempColor.offsetHSL(rand(-0.02, 0.02), rand(-0.04, 0.04), rand(-0.07, 0.10));
      setColor(streamCol, i * 3, tempColor);
    }

    const streamGeo = new THREE.BufferGeometry();
    streamGeo.setAttribute("position", new THREE.BufferAttribute(streamPos, 3));
    streamGeo.setAttribute("color", new THREE.BufferAttribute(streamCol, 3));
    streamGeo.setAttribute("aSize", new THREE.BufferAttribute(streamSize, 1));
    const streamMat = makePointMaterial(0.34, { additive: false });
    const streamPoints = new THREE.Points(streamGeo, streamMat);
    root.add(streamPoints);

    // ---------- Optional ambient falling petals (disabled; keep heart shedding only) ----------
    const FALL_COUNT = 0;
    const fallPos = new Float32Array(FALL_COUNT * 3);
    const fallCol = new Float32Array(FALL_COUNT * 3);
    const fallSize = new Float32Array(FALL_COUNT);
    const fallMeta = new Array(FALL_COUNT);

    for (let i = 0; i < FALL_COUNT; i++) {
      const miss = Math.random() < 0.12;
      fallMeta[i] = {
        phase: Math.random(),
        dur: rand(5.5, 9.5),
        seed: Math.random() * Math.PI * 2,
        spawnX: rand(-3.8, 3.8),
        spawnY: rand(4.5, 7.4),
        spawnZ: rand(-1.8, 1.8),
        targetIndex: (Math.random() * HEART_COUNT) | 0,
        miss,
        missX: miss ? rand(-2.2, 2.2) : 0,
        missY: miss ? rand(-2.7, -2.3) : 0,
        missZ: miss ? rand(-1.2, 1.2) : 0
      };
      fallSize[i] = rand(3, 7);
      tempColor.copy(Math.random() < 0.65 ? PINK : PINK2);
      tempColor.offsetHSL(rand(-0.02, 0.02), rand(-0.05, 0.03), rand(-0.05, 0.06));
      setColor(fallCol, i * 3, tempColor);
    }

    const fallGeo = new THREE.BufferGeometry();
    fallGeo.setAttribute("position", new THREE.BufferAttribute(fallPos, 3));
    fallGeo.setAttribute("color", new THREE.BufferAttribute(fallCol, 3));
    fallGeo.setAttribute("aSize", new THREE.BufferAttribute(fallSize, 1));
    const fallMat = makePointMaterial(0.26, { additive: false });
    const fallPoints = new THREE.Points(fallGeo, fallMat);
    root.add(fallPoints);

    // ---------- Heart halo for bloom ----------
    const HALO_COUNT = 70;
    const haloPos = new Float32Array(HALO_COUNT * 3);
    const haloCol = new Float32Array(HALO_COUNT * 3);
    const haloSize = new Float32Array(HALO_COUNT);
    for (let i = 0; i < HALO_COUNT; i++) {
      const t = heartTarget[(Math.random() * HEART_COUNT) | 0];
      haloPos[i * 3] = t.x + rand(-0.14, 0.14);
      haloPos[i * 3 + 1] = t.y + rand(-0.14, 0.14);
      haloPos[i * 3 + 2] = t.z + rand(-0.08, 0.08);
      setColor(haloCol, i * 3, Math.random() < 0.5 ? PINK : LAV);
      haloSize[i] = rand(10, 18);
    }
    const haloGeo = new THREE.BufferGeometry();
    haloGeo.setAttribute("position", new THREE.BufferAttribute(haloPos, 3));
    haloGeo.setAttribute("color", new THREE.BufferAttribute(haloCol, 3));
    haloGeo.setAttribute("aSize", new THREE.BufferAttribute(haloSize, 1));
    const haloMat = makePointMaterial(0.03, { additive: true });
    const haloPoints = new THREE.Points(haloGeo, haloMat);
    root.add(haloPoints);

    function updateFloor(t) {
      for (let i = 0; i < FLOOR_COUNT; i++) {
        const m = floorMeta[i];
        const wob = 0.12 * Math.sin(t * 0.28 + m.phi) + 0.05 * Math.sin(t * 1.2 + m.phi * 1.7);
        const r = m.r * (1 + wob * 0.05);
        floorPos[i * 3] = Math.cos(m.a + 0.02 * Math.sin(t * 0.22 + m.phi)) * r;
        floorPos[i * 3 + 1] = m.y + Math.sin(t * 0.8 + m.phi) * 0.02;
        floorPos[i * 3 + 2] = Math.sin(m.a) * r * m.oval + 0.02 * Math.cos(t + m.phi);
      }
      floorGeo.attributes.position.needsUpdate = true;
    }

    function updateHeart(t) {
      for (let i = 0; i < HEART_COUNT; i++) {
        const target = heartTarget[i];
        const s = heartSeed[i];

        const edgeJitter = 0.028;
        const pulse = 1 + 0.007 * Math.sin(t * 2.1 + s * 0.6);
        const x = target.x * pulse + Math.sin(t * 0.9 + s) * edgeJitter;
        const y = ((target.y - 2.15) * pulse + 2.15) + Math.cos(t * 1.0 + s * 0.7) * edgeJitter;
        const z = target.z * pulse + Math.sin(t * 0.8 + s * 1.1) * edgeJitter * 0.85;

        heartPos[i * 3] = x;
        heartPos[i * 3 + 1] = y;
        heartPos[i * 3 + 2] = z;
      }

      heartGeo.attributes.position.needsUpdate = true;
      heartMat.uniforms.uOpacity.value = 0.78 + 0.06 * Math.sin(t * 1.1);
    }

    function updateStream(t) {
      for (let i = 0; i < STREAM_COUNT; i++) {
        const m = streamMeta[i];
        const p = (t / m.dur + m.phase) % 1;
        const src = heartTarget[m.sourceIndex];
        const drift = smoothstep(0.0, 1.0, p);
        const fade = 1.0 - smoothstep(0.72, 1.0, p);

        const startX = src.x + Math.sin(m.seed) * 0.10;
        const startY = src.y + Math.cos(m.seed * 0.9) * 0.08;
        const startZ = src.z + Math.cos(m.seed * 1.1) * 0.07;

        const endX = src.x * 0.35 + m.x1;
        const endY = -2.55 + m.arc * 0.4;
        const endZ = src.z * 0.25 + m.z1;

        const x = THREE.MathUtils.lerp(startX, endX, drift)
          + Math.sin(t * 0.75 + m.seed + p * 5.0) * (0.03 + m.drift * 0.05);
        const y = THREE.MathUtils.lerp(startY, endY, drift)
          + Math.cos(t * 0.9 + m.seed * 0.5 + p * 4.0) * 0.025;
        const z = THREE.MathUtils.lerp(startZ, endZ, drift)
          + Math.cos(t * 0.7 + m.seed * 1.2 + p * 5.5) * (0.02 + m.drift * 0.04);

        streamPos[i * 3] = x;
        streamPos[i * 3 + 1] = y;
        streamPos[i * 3 + 2] = z;

        streamSize[i] = (2.6 + 2.8 * fade) * (0.85 + 0.15 * Math.sin(t * 1.2 + m.seed));
      }
      streamGeo.attributes.position.needsUpdate = true;
      streamGeo.attributes.aSize.needsUpdate = true;
      streamMat.uniforms.uOpacity.value = 0.22 + 0.04 * Math.sin(t * 0.8);
    }

    function updateFalling(t) {
      for (let i = 0; i < FALL_COUNT; i++) {
        const m = fallMeta[i];
        const p = (t / m.dur + m.phase) % 1;
        const target = heartTarget[m.targetIndex];

        let tx = target.x + Math.sin(m.seed) * 0.22;
        let ty = target.y + Math.cos(m.seed * 1.2) * 0.18;
        let tz = target.z + Math.cos(m.seed) * 0.12;
        if (m.miss) {
          tx = m.missX;
          ty = m.missY;
          tz = m.missZ;
        }

        const k = smoothstep(0, 1, p);
        const x = THREE.MathUtils.lerp(m.spawnX, tx, k) + Math.sin(m.seed + t * 0.85 + p * 7.0) * 0.24 * (1 - k * 0.65);
        const y = THREE.MathUtils.lerp(m.spawnY, ty, k) + Math.cos(m.seed * 0.7 + t * 0.9 + p * 6.0) * 0.07;
        const z = THREE.MathUtils.lerp(m.spawnZ, tz, k) + Math.cos(m.seed * 1.4 + t * 0.75 + p * 8.0) * 0.15;

        fallPos[i * 3] = x;
        fallPos[i * 3 + 1] = y;
        fallPos[i * 3 + 2] = z;
      }
      fallGeo.attributes.position.needsUpdate = true;
      fallMat.uniforms.uOpacity.value = 0.28 + 0.06 * Math.sin(t * 0.7 + 1.3);
    }

    function updateHalo(t) {
      for (let i = 0; i < HALO_COUNT; i++) {
        const base = i * 3;
        const target = heartTarget[(i * 7) % HEART_COUNT];
        haloPos[base] = target.x + Math.sin(t * 0.8 + i * 0.21) * 0.07;
        haloPos[base + 1] = target.y + Math.cos(t * 0.9 + i * 0.17) * 0.06;
        haloPos[base + 2] = target.z + Math.sin(t * 0.7 + i * 0.13) * 0.06;
      }
      haloGeo.attributes.position.needsUpdate = true;
      haloMat.uniforms.uOpacity.value = 0.035 + 0.02 * (0.5 + 0.5 * Math.sin(t * 1.6));
    }

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      updateFloor(t);
      updateHeart(t);
      updateStream(t);
      updateFalling(t);
      updateHalo(t);

      // Keep the camera mostly fixed so the heart silhouette stays readable.
      root.rotation.y = 0.18 + Math.sin(t * 0.14) * 0.018;
      root.rotation.x = -0.02 + Math.sin(t * 0.10) * 0.008;
      camera.position.x = 0.55 + Math.sin(t * 0.13) * 0.06;
      camera.position.y = 0.34 + Math.cos(t * 0.12) * 0.04;
      camera.lookAt(0, 0.55, 0);

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      const pr = Math.min(window.devicePixelRatio, 2);
      renderer.setPixelRatio(pr);
      heartMat.uniforms.uPixelRatio.value = pr;
      floorMat.uniforms.uPixelRatio.value = pr;
      streamMat.uniforms.uPixelRatio.value = pr;
      fallMat.uniforms.uPixelRatio.value = pr;
      haloMat.uniforms.uPixelRatio.value = pr;
    });
  </script>
</body>
</html>
